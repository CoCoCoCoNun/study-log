# 📅 YYYY.MM.DD Study Log

## 📌 오늘 배운 개념 요약

- 
- 
- 

---

## ✅ Buffer Overflow 방어 기술 (정리 예시)

오늘은 의문이 생겼다.
왜 scanf만으로 쉘 취득이 불가능한가?  
기본적으로 내가 하는 것은 문자열(%s)만 실험하고 있는데
%d %f 는 안되나?  ==> 기본적으로 4바이트만 저장함. 

## Link 방법
1. Static Link => 파일을 생성할 때 라이브러리를 포함해서 elf를 만듬.
    ==> 파일에 각각 라이브러리가 들어가기에 파일 크기가 큼.
2. Dynamic Link => 파일들이 하나의 라이브러리를 공유해서 elf를 만듬.(대부분의 상황에서 default)
    ==> 기본적으로 하나의 메모리에 매핑해서 라이브러리를 사용하기에 파일 크기 작고, 라이브러리 하나만 패치하면 되니 유연함.
    ==> 하지만 편리한 만큼.. 위험성이 있겠죠?

**Dynamic Link**
- 그러면 함수를 실행할 때 plt, got가 왜 필요한지 알 수 있다
- 라이브러리로 매핑해주는 역할이 필요하기 때문!!
- static 이라면 라이브러리가 이미 포함되어 있으니 해당 함수의 주소 (ex. <scanf>)를 요청하면 된다.
- 하지만 dynamic은 라이브러리가 프로그램 외부에 있고 이를 연결해주는 통로가 필요한데, 이것이 PLT(Procedure Linkage Table)
- dynamic link 프로그램에서 라이브러리의 함수를 만나면 우선, <scanf@plt>를 호출한다. 그러면 plt는 실제 함수가 있는 테이블에서 실제 함수주소를 가져오는데, 이때 테이블이 GOT(Global Offset Table)이다.

## plt 취약점.
- 같은 메모리 상에 매핑하다보니 취약점이 발생함. 라이브러리 내부 함수들의 상대적인 주소는 언제나 같음.
- 어떤 프로그램에서 공유된 라이브러리의 base_point를 알게 된다면? 주소를 계산해서 다른 함수를 실행시킬 수도 있음.


내가 실습하는 scanf("%s") exploit.<br>
null 값 때문에 주소값을 넘길 수가 없다. read를 불러야 하는데 read의 첫번째 인자는 0이어야하고 두번째 인자에도 0이 들어가야 할 것이다. 그럼 어떻게 부르지?<br>
근데 이걸 부를 수 있다면 내가 system 함수를 gadget으로 실행할 수도 있는 거 아닌가. rax = 59로 세팅하고 rdi, rsi, 

---

## 🧠 오늘의 느낀 점 ☑️
objdump -R 파일
nm -D 파일 | grep "LIBC"



---

## ❓ 오늘의 궁금한 점 🔍



---

## 🔖 내일 목표 🎯

